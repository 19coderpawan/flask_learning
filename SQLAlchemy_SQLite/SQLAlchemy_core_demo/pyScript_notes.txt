1."import sqlalchemy as db
    print(db.__version__)"

✅ Explanation:
->import sqlalchemy as db: imports the SQLAlchemy library and aliases it as db for easy use.
->print(db.__version__): prints the installed version of SQLAlchemy. Good for checking your environment.

2."engine=db.create_engine("sqlite:///Student.db")"
✅ Explanation:
    ->create_engine is the central object for connecting to databases in SQLAlchemy.

    ->"sqlite:///Student.db" is the connection URL.
       sqlite is the dialect (database type).

    ->/// means “this is a file on disk.”
    ->Student.db is the filename (SQLite will create this if it doesn't exist).

3.conn=engine.connect()    
✅ Explanation:
->Opens an actual connection to the database using the engine.
  You use conn to execute SQL statements.

✅ Analogy:
->The engine is your car. conn is starting the engine so you can drive.

4.metadata=db.MetaData()
✅ Explanation:
->MetaData is a container to hold information about your tables.
 You can think of it as your database schema blueprint.

5.Student=db.Table("student",metadata,
                 db.Column('id',db.Integer(),primary_key=True),
                 db.Column('name',db.String(20),nullable=False),
                 db.Column('branch',db.String(20),nullable=False))
✅ Explanation:
->This defines a table called "student" in Python code.
It's not yet created in the database — you're describing its structure.

✅ Column definitions:
->'id': Integer, primary key (unique, auto-increment in SQLite).
->'name': String of max length 20, cannot be null.
->'branch': String of max length 20, cannot be null.

✅ Analogy:
->You’re drafting the design of your "student" table before building it. 

6.metadata.create_All(engine)
✅ Explanation:
->This command actually creates all tables in metadata (here, just "student") in the database. 
 It checks if the table exists first — it won’t recreate or overwrite existing tables.

✅ Analogy:
You take your blueprint (metadata) and tell the builder (engine): "build this table in the database file."


